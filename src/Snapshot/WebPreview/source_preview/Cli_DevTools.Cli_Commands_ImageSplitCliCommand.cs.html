<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using DevTools.Cli.Ui;
using DevTools.Cli.Logging;
using DevTools.Cli.App;
using DevTools.Image.Engine;
using DevTools.Image.Models;

namespace DevTools.Cli.Commands;

public sealed class ImageSplitCliCommand : ICliCommand
{
    private readonly CliConsole _ui;
    private readonly CliInput _input;
    private readonly ImageSplitEngine _engine;

    public ImageSplitCliCommand(CliConsole ui, CliInput input)
    {
        _ui = ui;
        _input = input;
        _engine = new ImageSplitEngine();
    }

    public string Key =&gt; &quot;split&quot;;
    public string Name =&gt; &quot;Image Split&quot;;
    public string Description =&gt; &quot;Recorta componentes/sprites de imagem com transparencia.&quot;;

    public async Task&lt;int&gt; ExecuteAsync(CliLaunchOptions options, CancellationToken ct)
    {
        // 1. Resolve Parameters
        var inputPath = options.GetOption(&quot;input&quot;) ?? options.GetOption(&quot;file&quot;);
        var outputDir = options.GetOption(&quot;output&quot;) ?? options.GetOption(&quot;out&quot;);
        var baseName = options.GetOption(&quot;base-name&quot;) ?? options.GetOption(&quot;name&quot;);
        var extension = options.GetOption(&quot;extension&quot;) ?? options.GetOption(&quot;ext&quot;);
        var alphaStr = options.GetOption(&quot;alpha&quot;) ?? options.GetOption(&quot;threshold&quot;);
        var startIndexStr = options.GetOption(&quot;start-index&quot;) ?? options.GetOption(&quot;start&quot;);
        var overwriteStr = options.GetOption(&quot;overwrite&quot;);
        var minWStr = options.GetOption(&quot;min-w&quot;) ?? options.GetOption(&quot;width&quot;);
        var minHStr = options.GetOption(&quot;min-h&quot;) ?? options.GetOption(&quot;height&quot;);

        byte? alpha = byte.TryParse(alphaStr, out var a) ? a : null;
        int? startIndex = int.TryParse(startIndexStr, out var s) ? s : null;
        bool? overwrite = overwriteStr != null ? (overwriteStr == &quot;true&quot;) : null;
        int? minW = int.TryParse(minWStr, out var w) ? w : null;
        int? minH = int.TryParse(minHStr, out var h) ? h : null;

        // Interactive Fallback
        if (!options.IsNonInteractive)
        {
            if (string.IsNullOrWhiteSpace(inputPath))
            {
                inputPath = _input.ReadRequired(&quot;Arquivo de imagem&quot;, &quot;ex: C:\\Projetos\\icone.png&quot;);
                options.Options[&quot;input&quot;] = inputPath;
            }
            
            if (string.IsNullOrWhiteSpace(outputDir))
            {
                outputDir = _input.ReadOptional(&quot;Pasta de saida (opcional)&quot;, &quot;enter para usar a pasta da imagem&quot;);
                if (!string.IsNullOrWhiteSpace(outputDir)) options.Options[&quot;output&quot;] = outputDir;
            }
            
            if (string.IsNullOrWhiteSpace(baseName))
            {
                baseName = _input.ReadOptional(&quot;Base do nome (opcional)&quot;);
                if (!string.IsNullOrWhiteSpace(baseName)) options.Options[&quot;base-name&quot;] = baseName;
            }
            
            if (string.IsNullOrWhiteSpace(extension))
            {
                extension = _input.ReadOptional(&quot;Extensao (opcional)&quot;, &quot;ex: .png&quot;);
                if (!string.IsNullOrWhiteSpace(extension)) options.Options[&quot;extension&quot;] = extension;
            }

            // Advanced options usually asked together
            bool askAdvanced = alpha == null &amp;&amp; startIndex == null &amp;&amp; overwrite == null &amp;&amp; minW == null &amp;&amp; minH == null;
            if (askAdvanced)
            {
                var advanced = _input.ReadYesNo(&quot;Configurar opcoes avancadas&quot;, false);
                if (advanced)
                {
                    var alphaInt = _input.ReadOptionalInt(&quot;Alpha threshold&quot;, &quot;0-255, enter=10&quot;) ?? 10;
                    alpha = (byte)Math.Clamp(alphaInt, 0, 255);
                    options.Options[&quot;alpha&quot;] = alpha.Value.ToString();

                    startIndex = _input.ReadOptionalInt(&quot;Start index&quot;, &quot;enter=1&quot;) ?? 1;
                    options.Options[&quot;start-index&quot;] = startIndex.Value.ToString();

                    overwrite = _input.ReadYesNo(&quot;Sobrescrever&quot;, false);
                    options.Options[&quot;overwrite&quot;] = overwrite.Value.ToString().ToLowerInvariant();

                    minW = _input.ReadOptionalInt(&quot;Min largura&quot;, &quot;enter=3&quot;) ?? 3;
                    options.Options[&quot;min-w&quot;] = minW.Value.ToString();

                    minH = _input.ReadOptionalInt(&quot;Min altura&quot;, &quot;enter=3&quot;) ?? 3;
                    options.Options[&quot;min-h&quot;] = minH.Value.ToString();
                }
            }
        }

        // Defaults
        alpha ??= 10;
        startIndex ??= 1;
        overwrite ??= false;
        minW ??= 3;
        minH ??= 3;

        // Validation
        if (string.IsNullOrWhiteSpace(inputPath))
        {
            _ui.WriteError(&quot;Input file required (--input).&quot;);
            return 1;
        }

        var request = new ImageSplitRequest(
            inputPath,
            string.IsNullOrWhiteSpace(outputDir) ? null : outputDir,
            string.IsNullOrWhiteSpace(baseName) ? null : baseName,
            string.IsNullOrWhiteSpace(extension) ? null : extension,
            alpha.Value,
            startIndex.Value,
            overwrite.Value,
            minW.Value,
            minH.Value);

        using var progress = new CliProgressReporter(_ui.Theme);
        var result = await _engine.ExecuteAsync(request, progress, ct).ConfigureAwait(false);
        progress.Finish();

        if (!result.IsSuccess || result.Value is null)
        {
            WriteErrors(result.Errors);
            return 1;
        }

        var response = result.Value;
        
        if (!options.IsNonInteractive)
        {
            _ui.Section(&quot;Resumo&quot;);
            _ui.WriteKeyValue(&quot;Entrada&quot;, response.InputPath);
            _ui.WriteKeyValue(&quot;Saida&quot;, response.OutputDirectory);
            _ui.WriteKeyValue(&quot;Total&quot;, response.TotalComponents.ToString());

            if (response.Outputs.Count &gt; 0)
            {
                var show = _input.ReadYesNo(&quot;Mostrar arquivos gerados&quot;, false);
                if (show)
                {
                    _ui.Section(&quot;Arquivos&quot;);
                    foreach (var item in response.Outputs)
                        _ui.WriteLine($&quot;{item.Index}: {item.Path}&quot;);
                }
            }
        }

        return 0;
    }

    private void WriteErrors(IReadOnlyList&lt;DevTools.Core.Results.ErrorDetail&gt; errors)
    {
        CliErrorLogger.LogErrors(Key, errors);
        _ui.Section(&quot;Erros&quot;);
        foreach (var error in errors)
        {
            _ui.WriteError($&quot;{error.Code}: {error.Message}&quot;);
            if (!string.IsNullOrWhiteSpace(error.Details))
                _ui.WriteDim(error.Details);
        }
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>