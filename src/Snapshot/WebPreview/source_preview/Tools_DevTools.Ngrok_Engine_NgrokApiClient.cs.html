<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Net;
using System.Text.Json;
using DevTools.Ngrok.Models;

namespace DevTools.Ngrok.Engine;

public sealed class NgrokApiClient
{
    private readonly HttpClient _http;
    private readonly Uri _baseUri;

    public NgrokApiClient(HttpClient http, Uri baseUri)
    {
        _http = http ?? throw new ArgumentNullException(nameof(http));
        _baseUri = baseUri ?? throw new ArgumentNullException(nameof(baseUri));
    }

    public async Task&lt;IReadOnlyList&lt;TunnelInfo&gt;&gt; GetTunnelsAsync(
        TimeSpan timeout,
        int retryCount,
        CancellationToken ct = default)
    {
        using var resp = await SendAsync(HttpMethod.Get, &quot;api/tunnels&quot;, timeout, retryCount, ct).ConfigureAwait(false);
        var json = await resp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);

        try
        {
            using var doc = JsonDocument.Parse(json);

            if (!doc.RootElement.TryGetProperty(&quot;tunnels&quot;, out var tunnelsEl) ||
                tunnelsEl.ValueKind != JsonValueKind.Array)
            {
                return Array.Empty&lt;TunnelInfo&gt;();
            }

            var list = new List&lt;TunnelInfo&gt;();

            foreach (var t in tunnelsEl.EnumerateArray())
            {
                var name = GetStringOrEmpty(t, &quot;name&quot;);
                var proto = GetStringOrEmpty(t, &quot;proto&quot;);
                var publicUrl = GetStringOrEmpty(t, &quot;public_url&quot;);

                string? addr = null;
                if (t.TryGetProperty(&quot;config&quot;, out var cfg) &amp;&amp; cfg.ValueKind == JsonValueKind.Object)
                {
                    if (cfg.TryGetProperty(&quot;addr&quot;, out var addrEl) &amp;&amp; addrEl.ValueKind == JsonValueKind.String)
                        addr = addrEl.GetString();
                }

                if (string.IsNullOrWhiteSpace(name) &amp;&amp; string.IsNullOrWhiteSpace(publicUrl))
                    continue;

                list.Add(new TunnelInfo(name, proto, publicUrl, addr));
            }

            return list;
        }
        catch (JsonException ex)
        {
            throw new NgrokApiException(&quot;ngrok.api.json_invalid&quot;, &quot;Ngrok API returned invalid JSON.&quot;, ex.Message, resp.StatusCode, ex);
        }
    }

    public async Task&lt;bool&gt; CloseTunnelAsync(
        string name,
        TimeSpan timeout,
        int retryCount,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new NgrokApiException(&quot;ngrok.tunnel.required&quot;, &quot;Tunnel name is required.&quot;);

        var encoded = Uri.EscapeDataString(name);
        using var resp = await SendAsync(HttpMethod.Delete, $&quot;api/tunnels/{encoded}&quot;, timeout, retryCount, ct)
            .ConfigureAwait(false);

        return resp.IsSuccessStatusCode;
    }

    private async Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpMethod method,
        string relativePath,
        TimeSpan timeout,
        int retryCount,
        CancellationToken ct)
    {
        var attempts = Math.Max(0, retryCount) + 1;

        for (var attempt = 1; attempt &lt;= attempts; attempt++)
        {
            using var request = new HttpRequestMessage(method, new Uri(_baseUri, relativePath));
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            cts.CancelAfter(timeout);

            try
            {
                var resp = await _http.SendAsync(request, cts.Token).ConfigureAwait(false);

                if (!resp.IsSuccessStatusCode)
                {
                    var body = await SafeReadBody(resp, ct).ConfigureAwait(false);
                    throw new NgrokApiException(
                        &quot;ngrok.api.http_error&quot;,
                        $&quot;Ngrok API returned {(int)resp.StatusCode} ({resp.StatusCode}).&quot;,
                        body,
                        resp.StatusCode);
                }

                return resp;
            }
            catch (NgrokApiException)
            {
                throw;
            }
            catch (OperationCanceledException ex) when (!ct.IsCancellationRequested)
            {
                if (attempt &lt; attempts)
                {
                    await Task.Delay(200, ct).ConfigureAwait(false);
                    continue;
                }

                throw new NgrokApiException(
                    &quot;ngrok.api.timeout&quot;,
                    &quot;Ngrok API request timed out.&quot;,
                    ex.Message,
                    null,
                    ex);
            }
            catch (HttpRequestException ex)
            {
                if (attempt &lt; attempts)
                {
                    await Task.Delay(200, ct).ConfigureAwait(false);
                    continue;
                }

                throw new NgrokApiException(
                    &quot;ngrok.api.unreachable&quot;,
                    &quot;Ngrok API is unreachable.&quot;,
                    ex.Message,
                    null,
                    ex);
            }
        }

        throw new NgrokApiException(&quot;ngrok.api.unreachable&quot;, &quot;Ngrok API is unreachable.&quot;);
    }

    private static async Task&lt;string?&gt; SafeReadBody(HttpResponseMessage response, CancellationToken ct)
    {
        try
        {
            var body = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            return string.IsNullOrWhiteSpace(body) ? null : body.Trim();
        }
        catch
        {
            return null;
        }
    }

    private static string GetStringOrEmpty(JsonElement obj, string prop)
    {
        if (!obj.TryGetProperty(prop, out var el))
            return string.Empty;

        return el.ValueKind == JsonValueKind.String
            ? (el.GetString() ?? string.Empty)
            : string.Empty;
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>