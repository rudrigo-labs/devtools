<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Text.RegularExpressions;
using DevTools.Harvest.Configuration;
using DevTools.Harvest.Models;

namespace DevTools.Harvest.Engine;

internal sealed class DependencyGraphBuilder
{
    private static readonly Regex UsingRegex = new(
        @&quot;^\s*using\s+(?:static\s+)?(?:\w+\s*=\s*)?([A-Za-z0-9_.]+)\s*;&quot;,
        RegexOptions.Compiled | RegexOptions.Multiline);

    private static readonly Regex NewTypeRegex = new(
        @&quot;\bnew\s+([A-Za-z_][A-Za-z0-9_]*)\b&quot;,
        RegexOptions.Compiled);

    private static readonly Regex StaticAccessRegex = new(
        @&quot;\b([A-Za-z_][A-Za-z0-9_]*)\s*\.&quot;,
        RegexOptions.Compiled);

    private static readonly Regex GenericTypeRegex = new(
        @&quot;\b([A-Za-z_][A-Za-z0-9_]*)\s*&lt;&quot;,
        RegexOptions.Compiled);

    private static readonly Regex BaseTypeRegex = new(
        @&quot;:\s*([A-Za-z_][A-Za-z0-9_]*)&quot;,
        RegexOptions.Compiled);

    private static readonly Regex JsImportRegex = new(
        @&quot;^\s*import\s+.*?\s+from\s+[&#39;&quot;&quot;]([^&#39;&quot;&quot;]+)[&#39;&quot;&quot;]&quot;,
        RegexOptions.Compiled | RegexOptions.Multiline);

    private static readonly Regex JsSideEffectImportRegex = new(
        @&quot;^\s*import\s+[&#39;&quot;&quot;]([^&#39;&quot;&quot;]+)[&#39;&quot;&quot;]&quot;,
        RegexOptions.Compiled | RegexOptions.Multiline);

    private static readonly Regex JsRequireRegex = new(
        @&quot;\brequire\(\s*[&#39;&quot;&quot;]([^&#39;&quot;&quot;]+)[&#39;&quot;&quot;]\s*\)&quot;,
        RegexOptions.Compiled);

    public DependencyGraph Build(IReadOnlyList&lt;FileNode&gt; files, HarvestRules rules, string rootPath, CancellationToken ct)
    {
        var fanIn = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase);
        var fanOut = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase);

        var namespaceMap = new Dictionary&lt;string, List&lt;FileNode&gt;&gt;(StringComparer.OrdinalIgnoreCase);
        var typeMap = new Dictionary&lt;string, List&lt;FileNode&gt;&gt;(StringComparer.Ordinal);

        foreach (var file in files)
        {
            ct.ThrowIfCancellationRequested();

            fanIn[file.FullPath] = 0;
            fanOut[file.FullPath] = 0;

            if (file.Extension.Equals(&quot;.cs&quot;, StringComparison.OrdinalIgnoreCase))
            {
                if (!string.IsNullOrWhiteSpace(file.Namespace))
                {
                    if (!namespaceMap.TryGetValue(file.Namespace, out var list))
                    {
                        list = new List&lt;FileNode&gt;();
                        namespaceMap[file.Namespace] = list;
                    }

                    list.Add(file);
                }

                foreach (var typeName in file.DeclaredTypes)
                {
                    if (!typeMap.TryGetValue(typeName, out var list))
                    {
                        list = new List&lt;FileNode&gt;();
                        typeMap[typeName] = list;
                    }

                    list.Add(file);
                }
            }
        }

        var allowedExtensions = new HashSet&lt;string&gt;(rules.Extensions, StringComparer.OrdinalIgnoreCase);
        var fileByFullPath = files.ToDictionary(f =&gt; f.FullPath, StringComparer.OrdinalIgnoreCase);

        foreach (var file in files)
        {
            ct.ThrowIfCancellationRequested();

            var outgoing = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase);

            if (file.Extension.Equals(&quot;.cs&quot;, StringComparison.OrdinalIgnoreCase))
            {
                foreach (var ns in ExtractUsings(file.Content, rules.IgnoreUsingPrefixes))
                {
                    if (namespaceMap.TryGetValue(ns, out var targets))
                        AddTargets(outgoing, targets);
                    else
                        AddNamespacePrefixMatches(outgoing, namespaceMap, ns);
                }

                var identifiers = ExtractTypeUsageTokens(file.Content);
                foreach (var identifier in identifiers)
                {
                    if (typeMap.TryGetValue(identifier, out var targets))
                        AddTargets(outgoing, targets);
                }
            }
            else if (IsJsOrTs(file.Extension))
            {
                foreach (var specifier in ExtractJsImports(file.Content))
                {
                    var target = ResolveJsTsImport(specifier, file.FullPath, rootPath, allowedExtensions, fileByFullPath);
                    if (target is not null)
                        outgoing.Add(target.FullPath);
                }
            }

            outgoing.Remove(file.FullPath);

            fanOut[file.FullPath] = outgoing.Count;

            foreach (var target in outgoing)
            {
                if (fanIn.ContainsKey(target))
                    fanIn[target] += 1;
            }
        }

        return new DependencyGraph(fanIn, fanOut);
    }

    private static bool IsJsOrTs(string extension)
        =&gt; extension.Equals(&quot;.js&quot;, StringComparison.OrdinalIgnoreCase)
            || extension.Equals(&quot;.ts&quot;, StringComparison.OrdinalIgnoreCase);

    private static IEnumerable&lt;string&gt; ExtractUsings(string content, IReadOnlyList&lt;string&gt; ignoredPrefixes)
    {
        foreach (Match match in UsingRegex.Matches(content))
        {
            if (match.Groups.Count &lt; 2) continue;
            var value = match.Groups[1].Value.Trim();
            if (!string.IsNullOrWhiteSpace(value) &amp;&amp; !IsIgnoredUsing(value, ignoredPrefixes))
                yield return value;
        }
    }

    private static HashSet&lt;string&gt; ExtractTypeUsageTokens(string content)
    {
        var set = new HashSet&lt;string&gt;(StringComparer.Ordinal);
        CollectMatches(set, NewTypeRegex.Matches(content));
        CollectMatches(set, StaticAccessRegex.Matches(content));
        CollectMatches(set, GenericTypeRegex.Matches(content));
        CollectMatches(set, BaseTypeRegex.Matches(content));
        return set;
    }

    private static void CollectMatches(HashSet&lt;string&gt; set, MatchCollection matches)
    {
        foreach (Match match in matches)
        {
            if (!match.Success) continue;
            if (match.Groups.Count &lt; 2) continue;
            var value = match.Groups[1].Value.Trim();
            if (!string.IsNullOrWhiteSpace(value))
                set.Add(value);
        }
    }

    private static bool IsIgnoredUsing(string ns, IReadOnlyList&lt;string&gt; ignoredPrefixes)
    {
        if (ignoredPrefixes.Count == 0)
            return false;

        foreach (var prefix in ignoredPrefixes)
        {
            if (string.IsNullOrWhiteSpace(prefix)) continue;
            if (ns.Equals(prefix, StringComparison.OrdinalIgnoreCase))
                return true;
            if (ns.StartsWith(prefix + &quot;.&quot;, StringComparison.OrdinalIgnoreCase))
                return true;
        }

        return false;
    }

    private static void AddNamespacePrefixMatches(
        HashSet&lt;string&gt; outgoing,
        IDictionary&lt;string, List&lt;FileNode&gt;&gt; namespaceMap,
        string ns)
    {
        foreach (var kvp in namespaceMap)
        {
            if (!kvp.Key.StartsWith(ns + &quot;.&quot;, StringComparison.OrdinalIgnoreCase))
                continue;

            AddTargets(outgoing, kvp.Value);
        }
    }

    private static void AddTargets(HashSet&lt;string&gt; outgoing, IEnumerable&lt;FileNode&gt; targets)
    {
        foreach (var target in targets)
            outgoing.Add(target.FullPath);
    }

    private static IEnumerable&lt;string&gt; ExtractJsImports(string content)
    {
        foreach (Match match in JsImportRegex.Matches(content))
        {
            if (match.Groups.Count &lt; 2) continue;
            var value = match.Groups[1].Value.Trim();
            if (!string.IsNullOrWhiteSpace(value))
                yield return value;
        }

        foreach (Match match in JsSideEffectImportRegex.Matches(content))
        {
            if (match.Groups.Count &lt; 2) continue;
            var value = match.Groups[1].Value.Trim();
            if (!string.IsNullOrWhiteSpace(value))
                yield return value;
        }

        foreach (Match match in JsRequireRegex.Matches(content))
        {
            if (match.Groups.Count &lt; 2) continue;
            var value = match.Groups[1].Value.Trim();
            if (!string.IsNullOrWhiteSpace(value))
                yield return value;
        }
    }

    private static FileNode? ResolveJsTsImport(
        string specifier,
        string sourceFullPath,
        string root,
        IReadOnlySet&lt;string&gt; allowedExtensions,
        IReadOnlyDictionary&lt;string, FileNode&gt; fileByFullPath)
    {
        if (string.IsNullOrWhiteSpace(specifier))
            return null;

        var isRelative = specifier.StartsWith(&quot;.&quot;, StringComparison.OrdinalIgnoreCase);
        var isRooted = specifier.StartsWith(&quot;/&quot;, StringComparison.OrdinalIgnoreCase);
        if (!isRelative &amp;&amp; !isRooted)
            return null;

        var basePath = isRooted
            ? Path.GetFullPath(Path.Combine(root, specifier.TrimStart(&#39;/&#39;)))
            : Path.GetFullPath(Path.Combine(Path.GetDirectoryName(sourceFullPath) ?? root, specifier));

        var candidates = new List&lt;string&gt;();

        if (Path.HasExtension(basePath))
        {
            candidates.Add(basePath);
        }
        else
        {
            foreach (var ext in allowedExtensions)
                candidates.Add(basePath + ext);

            foreach (var ext in allowedExtensions)
                candidates.Add(Path.Combine(basePath, &quot;index&quot; + ext));
        }

        foreach (var candidate in candidates)
        {
            if (fileByFullPath.TryGetValue(candidate, out var file))
                return file;
        }

        return null;
    }

    internal sealed record DependencyGraph(
        IReadOnlyDictionary&lt;string, int&gt; FanIn,
        IReadOnlyDictionary&lt;string, int&gt; FanOut)
    {
        public int GetFanIn(string fullPath)
            =&gt; FanIn.TryGetValue(fullPath, out var value) ? value : 0;

        public int GetFanOut(string fullPath)
            =&gt; FanOut.TryGetValue(fullPath, out var value) ? value : 0;
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>