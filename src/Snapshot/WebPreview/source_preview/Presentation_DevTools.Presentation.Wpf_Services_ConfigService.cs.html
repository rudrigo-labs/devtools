<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System;
using System.IO;
using System.Text.Json;
using System.Collections.Generic;
using DevTools.SSHTunnel.Models;
using DevTools.Harvest.Configuration;

namespace DevTools.Presentation.Wpf.Services;

public class SshConfigSection
{
    public List&lt;TunnelProfile&gt; Profiles { get; set; } = new();
}

public class ConfigService
{
    private readonly string _configPath;
    
    public ConfigService()
    {
        // Alterado para a raiz da aplica&#231;&#227;o (onde o .exe est&#225;)
        _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;appsettings.json&quot;);
    }

    public string ConfigPath =&gt; _configPath;

    public bool IsConfigured()
    {
        // Simple validation: File must exist and have valid JSON content
        if (!File.Exists(_configPath))
            return false;

        try
        {
            var content = File.ReadAllText(_configPath);
            if (string.IsNullOrWhiteSpace(content))
                return false;

            JsonDocument.Parse(content); // Just validates JSON syntax
            return true;
        }
        catch
        {
            return false;
        }
    }

    public T GetSection&lt;T&gt;(string sectionName) where T : new()
    {
        if (!File.Exists(_configPath)) return new T();

        try
        {
            var json = File.ReadAllText(_configPath);
            using var doc = JsonDocument.Parse(json);
            if (doc.RootElement.TryGetProperty(sectionName, out var section))
            {
                return JsonSerializer.Deserialize&lt;T&gt;(section.GetRawText(), new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new T();
            }
        }
        catch
        {
            // Ignore errors
        }
        return new T();
    }

    public void SaveSection&lt;T&gt;(string sectionName, T data)
    {
        var root = new System.Collections.Generic.Dictionary&lt;string, object&gt;();
        
        // Read existing
        if (File.Exists(_configPath))
        {
            try
            {
                var json = File.ReadAllText(_configPath);
                root = JsonSerializer.Deserialize&lt;System.Collections.Generic.Dictionary&lt;string, object&gt;&gt;(json) ?? new();
            }
            catch { }
        }

        // Update section
        // We use JsonElement to keep other sections intact, but for the updated section we need to serialize it to object (or JsonElement)
        // A simple way is to serialize &#39;data&#39; to JsonElement and put it in the dictionary
        var sectionJson = JsonSerializer.SerializeToElement(data);
        root[sectionName] = sectionJson;

        // Save back
        try
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var finalJson = JsonSerializer.Serialize(root, options);
            File.WriteAllText(_configPath, finalJson);
        }
        catch { }
    }

    public void CreateDefaultIfNotExists()
    {
        if (File.Exists(_configPath))
            return;

        var defaultContent = new
        {
            ConnectionStrings = new { },
            Email = new 
            {
                SmtpHost = &quot;&quot;,
                SmtpPort = 587,
                Username = &quot;&quot;,
                Password = &quot;&quot;
            },
            Ssh = new 
            {
                Profiles = new[] 
                {
                    new 
                    {
                        Name = &quot;default&quot;,
                        SshHost = &quot;&quot;,
                        SshPort = 22,
                        SshUser = &quot;&quot;,
                        LocalBindHost = &quot;127.0.0.1&quot;,
                        LocalPort = 14331,
                        RemoteHost = &quot;127.0.0.1&quot;,
                        RemotePort = 1433,
                        StrictHostKeyChecking = &quot;Default&quot;, // Default, Yes, No, Ask
                        ConnectTimeoutSeconds = (int?)null
                    }
                }
            },
            Harvest = new HarvestConfig
            {
                MinScoreDefault = 0,
                TopDefault = 100,
                Weights = new HarvestWeights
                {
                    FanInWeight = 2.0,
                    FanOutWeight = 0.5,
                    KeywordDensityWeight = 1.0,
                    DeadCodePenalty = 5.0
                },
                Rules = new HarvestRules
                {
                    Extensions = new List&lt;string&gt; { &quot;.cs&quot;, &quot;.xml&quot;, &quot;.json&quot;, &quot;.xaml&quot; },
                    ExcludeDirectories = new List&lt;string&gt; { &quot;bin&quot;, &quot;obj&quot;, &quot;.git&quot;, &quot;node_modules&quot; }
                }
            }
        };

        try
        {
            var json = JsonSerializer.Serialize(defaultContent, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(_configPath, json);
        }
        catch
        {
            // Ignore write errors
        }
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>