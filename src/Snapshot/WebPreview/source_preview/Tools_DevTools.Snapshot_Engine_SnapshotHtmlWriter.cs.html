<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Net;
using System.Text;

namespace DevTools.Snapshot.Engine;

internal sealed class SnapshotHtmlWriter
{
    private const string PrismBase = &quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0&quot;;
    private const string PrismThemeUrl = PrismBase + &quot;/themes/prism-tomorrow.min.css&quot;;
    private const string PrismCoreUrl = PrismBase + &quot;/prism.min.js&quot;;

    private static readonly HashSet&lt;string&gt; PreviewExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        &quot;.cs&quot;, &quot;.csx&quot;, &quot;.json&quot;, &quot;.xml&quot;, &quot;.config&quot;,
        &quot;.csproj&quot;, &quot;.sln&quot;, &quot;.props&quot;, &quot;.targets&quot;,
        &quot;.yml&quot;, &quot;.yaml&quot;,
        &quot;.md&quot;, &quot;.txt&quot;,
        &quot;.editorconfig&quot;, &quot;.gitignore&quot;, &quot;.gitattributes&quot;,
        &quot;.env&quot;, &quot;.ini&quot;, &quot;.sql&quot;, &quot;.http&quot;, &quot;.dockerignore&quot;,
        &quot;.html&quot;, &quot;.htm&quot;,
        &quot;.css&quot;, &quot;.scss&quot;, &quot;.sass&quot;, &quot;.less&quot;,
        &quot;.js&quot;, &quot;.mjs&quot;, &quot;.cjs&quot;,
        &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.jsx&quot;,
        &quot;.cshtml&quot;, &quot;.razor&quot;,
        &quot;.ps1&quot;, &quot;.sh&quot;, &quot;.bat&quot;,
        &quot;.graphql&quot;, &quot;.proto&quot;
    };

    private static readonly HashSet&lt;string&gt; TextFilesWithoutExtension = new(StringComparer.OrdinalIgnoreCase)
    {
        &quot;Dockerfile&quot;,
        &quot;README&quot;,
        &quot;LICENSE&quot;,
        &quot;Makefile&quot;
    };

    private static readonly HashSet&lt;string&gt; ImageExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        &quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.svg&quot;, &quot;.webp&quot;, &quot;.ico&quot;
    };

    private static readonly Dictionary&lt;string, string&gt; PrismByExtension = new(StringComparer.OrdinalIgnoreCase)
    {
        [&quot;.cs&quot;] = &quot;csharp&quot;,
        [&quot;.csx&quot;] = &quot;csharp&quot;,
        [&quot;.json&quot;] = &quot;json&quot;,
        [&quot;.yml&quot;] = &quot;yaml&quot;,
        [&quot;.yaml&quot;] = &quot;yaml&quot;,
        [&quot;.md&quot;] = &quot;markdown&quot;,
        [&quot;.xml&quot;] = &quot;markup&quot;,
        [&quot;.config&quot;] = &quot;markup&quot;,
        [&quot;.csproj&quot;] = &quot;markup&quot;,
        [&quot;.html&quot;] = &quot;markup&quot;,
        [&quot;.htm&quot;] = &quot;markup&quot;,
        [&quot;.cshtml&quot;] = &quot;markup&quot;,
        [&quot;.razor&quot;] = &quot;markup&quot;,
        [&quot;.css&quot;] = &quot;css&quot;,
        [&quot;.js&quot;] = &quot;javascript&quot;,
        [&quot;.mjs&quot;] = &quot;javascript&quot;,
        [&quot;.cjs&quot;] = &quot;javascript&quot;,
        [&quot;.ts&quot;] = &quot;typescript&quot;,
        [&quot;.tsx&quot;] = &quot;tsx&quot;,
        [&quot;.jsx&quot;] = &quot;jsx&quot;,
        [&quot;.sql&quot;] = &quot;sql&quot;,
        [&quot;.ps1&quot;] = &quot;powershell&quot;,
        [&quot;.sh&quot;] = &quot;bash&quot;,
        [&quot;.bat&quot;] = &quot;batch&quot;,
        [&quot;.graphql&quot;] = &quot;graphql&quot;,
        [&quot;.proto&quot;] = &quot;protobuf&quot;
    };

    private static readonly Dictionary&lt;string, string[]&gt; PrismDeps = new(StringComparer.OrdinalIgnoreCase)
    {
        [&quot;typescript&quot;] = new[] { &quot;javascript&quot; },
        [&quot;tsx&quot;] = new[] { &quot;typescript&quot;, &quot;jsx&quot;, &quot;javascript&quot; },
        [&quot;jsx&quot;] = new[] { &quot;javascript&quot; },
        [&quot;graphql&quot;] = new[] { &quot;javascript&quot; }
    };

    private IReadOnlyList&lt;string&gt; _prismScripts = Array.Empty&lt;string&gt;();
    private string? _firstFileFallback;
    private string? _programCsFile;
    private string? _readmeMdFile;

    public async Task WriteAsync(
        string projectName,
        string rootPath,
        string outDir,
        IReadOnlySet&lt;string&gt; ignoreDirs,
        long? maxFileSizeBytes)
    {
        if (string.IsNullOrWhiteSpace(rootPath))
            throw new ArgumentException(&quot;rootPath is required.&quot;, nameof(rootPath));

        if (!Directory.Exists(rootPath))
            throw new DirectoryNotFoundException($&quot;RootPath not found: {rootPath}&quot;);

        if (string.IsNullOrWhiteSpace(outDir))
            throw new ArgumentException(&quot;outDir is required.&quot;, nameof(outDir));

        var ignore = new HashSet&lt;string&gt;(ignoreDirs, StringComparer.OrdinalIgnoreCase)
        {
            &quot;Snapshot&quot;,
            new DirectoryInfo(outDir).Name
        };

        var filesDir = Path.Combine(outDir, &quot;source_preview&quot;);

        if (Directory.Exists(outDir))
            Directory.Delete(outDir, true);

        Directory.CreateDirectory(filesDir);

        var neededPrism = DetectNeededPrismComponents(rootPath);
        ResolvePrismDependencies(neededPrism);

        _prismScripts = neededPrism
            .OrderBy(x =&gt; x, StringComparer.OrdinalIgnoreCase)
            .Select(x =&gt; $&quot;../prism-{x}.min.js&quot;)
            .ToList();

        await DownloadPrismFiles(outDir, neededPrism);

        _firstFileFallback = null;
        _programCsFile = null;
        _readmeMdFile = null;

        var sbIndex = new StringBuilder();
        BuildHtmlHeader(sbIndex, projectName);

        var root = new DirectoryInfo(rootPath);
        await ProcessDirectoryAsync(root, rootPath, filesDir, sbIndex, ignore, maxFileSizeBytes);

        var initialSrc = _readmeMdFile ?? _programCsFile ?? _firstFileFallback ?? string.Empty;

        sbIndex.Append($&quot;&lt;/div&gt;&lt;div class=&#39;content&#39;&gt;&lt;iframe name=&#39;viewer&#39; src=&#39;{WebUtility.HtmlEncode(initialSrc)}&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);

        await File.WriteAllTextAsync(Path.Combine(outDir, &quot;index.html&quot;), sbIndex.ToString(), Encoding.UTF8);
    }

    private async Task ProcessDirectoryAsync(
        DirectoryInfo dir,
        string rootPath,
        string filesDir,
        StringBuilder sb,
        IReadOnlySet&lt;string&gt; ignore,
        long? maxFileSizeBytes)
    {
        var entries = dir.GetFileSystemInfos()
            .Where(e =&gt; !ignore.Contains(e.Name))
            .OrderBy(e =&gt; e is FileInfo ? 1 : 0)
            .ThenBy(e =&gt; e.Name, StringComparer.OrdinalIgnoreCase);

        sb.Append(&quot;&lt;ul&gt;&quot;);

        foreach (var entry in entries)
        {
            if (entry is DirectoryInfo subDir)
            {
                sb.Append($&quot;&lt;li&gt;&lt;details&gt;&lt;summary&gt;&#128193; {WebUtility.HtmlEncode(subDir.Name)}&lt;/summary&gt;&quot;);
                await ProcessDirectoryAsync(subDir, rootPath, filesDir, sb, ignore, maxFileSizeBytes);
                sb.Append(&quot;&lt;/details&gt;&lt;/li&gt;&quot;);
                continue;
            }

            if (entry is FileInfo file &amp;&amp; IsPreviewable(file, maxFileSizeBytes))
            {
                var relativePath = Path.GetRelativePath(rootPath, file.FullName);
                var htmlFileName = relativePath
                    .Replace(Path.DirectorySeparatorChar, &#39;_&#39;)
                    .Replace(Path.AltDirectorySeparatorChar, &#39;_&#39;)
                    + &quot;.html&quot;;

                await GenerateCodeHtmlPageAsync(file, Path.Combine(filesDir, htmlFileName));

                var viewerHref = $&quot;source_preview/{htmlFileName}&quot;;

                _firstFileFallback ??= viewerHref;

                if (_readmeMdFile == null &amp;&amp; file.Name.Equals(&quot;README.md&quot;, StringComparison.OrdinalIgnoreCase))
                    _readmeMdFile = viewerHref;
                else if (_programCsFile == null &amp;&amp; file.Name.Equals(&quot;Program.cs&quot;, StringComparison.OrdinalIgnoreCase))
                    _programCsFile = viewerHref;

                sb.Append($&quot;&lt;li&gt;&lt;a href=&#39;{WebUtility.HtmlEncode(viewerHref)}&#39; target=&#39;viewer&#39;&gt;&#128196; {WebUtility.HtmlEncode(file.Name)}&lt;/a&gt;&lt;/li&gt;&quot;);
            }
            else if (entry is FileInfo f2 &amp;&amp; ImageExtensions.Contains(f2.Extension))
            {
                sb.Append($&quot;&lt;li&gt;&lt;span style=&#39;opacity:.7&#39;&gt;&#128444;️ {WebUtility.HtmlEncode(f2.Name)} (image)&lt;/span&gt;&lt;/li&gt;&quot;);
            }
        }

        sb.Append(&quot;&lt;/ul&gt;&quot;);
    }

    private static bool IsPreviewable(FileInfo file, long? maxFileSizeBytes)
    {
        if (ImageExtensions.Contains(file.Extension))
            return false;

        if (maxFileSizeBytes.HasValue &amp;&amp; file.Length &gt; maxFileSizeBytes.Value)
            return false;

        if (string.IsNullOrEmpty(file.Extension))
            return TextFilesWithoutExtension.Contains(file.Name);

        return PreviewExtensions.Contains(file.Extension);
    }

    private async Task GenerateCodeHtmlPageAsync(FileInfo file, string targetPath)
    {
        var code = await File.ReadAllTextAsync(file.FullName);
        var langClass = GetLanguageClass(file);

        var scripts = new StringBuilder();
        scripts.AppendLine(&quot;&lt;script src=&#39;../prism.min.js&#39;&gt;&lt;/script&gt;&quot;);
        foreach (var s in _prismScripts)
            scripts.AppendLine($&quot;&lt;script src=&#39;{s}&#39;&gt;&lt;/script&gt;&quot;);

        var html = $@&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; href=&#39;../prism-tomorrow.min.css&#39;&gt;
&lt;style&gt;
body {{ background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }}
pre {{ border-radius: 6px; }}
&lt;/style&gt;
&lt;/head&gt;&lt;body&gt;
&lt;pre&gt;&lt;code class=&#39;{langClass}&#39;&gt;{WebUtility.HtmlEncode(code)}&lt;/code&gt;&lt;/pre&gt;
{scripts}
&lt;/body&gt;&lt;/html&gt;&quot;;

        await File.WriteAllTextAsync(targetPath, html, Encoding.UTF8);
    }

    private static string GetLanguageClass(FileInfo file)
    {
        if (string.IsNullOrEmpty(file.Extension))
            return &quot;language-none&quot;;

        if (PrismByExtension.TryGetValue(file.Extension, out var prismComponent))
            return $&quot;language-{prismComponent}&quot;;

        return &quot;language-none&quot;;
    }

    private static HashSet&lt;string&gt; DetectNeededPrismComponents(string rootPath)
    {
        var needed = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase)
        {
            &quot;csharp&quot;,
            &quot;json&quot;,
            &quot;markup&quot;,
            &quot;markdown&quot;,
            &quot;yaml&quot;
        };

        foreach (var file in Directory.EnumerateFiles(rootPath, &quot;*&quot;, SearchOption.AllDirectories))
        {
            var ext = Path.GetExtension(file);
            if (string.IsNullOrEmpty(ext))
                continue;

            if (PrismByExtension.TryGetValue(ext, out var component))
                needed.Add(component);
        }

        return needed;
    }

    private static void ResolvePrismDependencies(HashSet&lt;string&gt; needed)
    {
        bool changed;
        do
        {
            changed = false;
            foreach (var c in needed.ToList())
            {
                if (!PrismDeps.TryGetValue(c, out var deps))
                    continue;

                foreach (var dep in deps)
                {
                    if (needed.Add(dep))
                        changed = true;
                }
            }
        } while (changed);
    }

    private async Task DownloadPrismFiles(string targetDir, IReadOnlySet&lt;string&gt; components)
    {
        Directory.CreateDirectory(targetDir);

        using var client = new HttpClient();
        client.DefaultRequestHeaders.UserAgent.ParseAdd(&quot;SnapshotGenerator/1.0&quot;);

        var downloads = new List&lt;(string url, string fileName)&gt;
        {
            (PrismThemeUrl, &quot;prism-tomorrow.min.css&quot;),
            (PrismCoreUrl, &quot;prism.min.js&quot;)
        };

        foreach (var c in components.OrderBy(x =&gt; x, StringComparer.OrdinalIgnoreCase))
        {
            var url = $&quot;{PrismBase}/components/prism-{c}.min.js&quot;;
            var fileName = $&quot;prism-{c}.min.js&quot;;
            downloads.Add((url, fileName));
        }

        var tasks = downloads.Select(d =&gt;
            DownloadFile(client, d.url, Path.Combine(targetDir, d.fileName))
        );

        await Task.WhenAll(tasks);
    }

    private static async Task DownloadFile(HttpClient client, string url, string destination)
    {
        if (File.Exists(destination))
            return;

        using var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
        if (!response.IsSuccessStatusCode)
            throw new InvalidOperationException($&quot;Failed to download Prism asset ({response.StatusCode}): {url}&quot;);

        await using var httpStream = await response.Content.ReadAsStreamAsync();
        await using var fileStream = File.Create(destination);
        await httpStream.CopyToAsync(fileStream);
    }

    private static void BuildHtmlHeader(StringBuilder sb, string title)
    {
        sb.Append($@&quot;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&#39;UTF-8&#39;&gt;
    &lt;title&gt;Preview: {WebUtility.HtmlEncode(title)}&lt;/title&gt;
    &lt;style&gt;
        body {{ display: flex; height: 100vh; margin: 0; font-family: &#39;Segoe UI&#39;, Tahoma, sans-serif; background: #252526; color: #ccc; }}
        .sidebar {{ width: 340px; border-right: 1px solid #333; overflow-y: auto; padding: 15px; }}
        .content {{ flex: 1; background: #1e1e1e; }}
        iframe {{ width: 100%; height: 100%; border: none; }}
        ul {{ list-style: none; padding-left: 15px; margin: 5px 0; }}
        li {{ margin: 3px 0; }}
        summary {{ cursor: pointer; padding: 2px; color: #e1e1e1; outline: none; }}
        summary:hover {{ background: #37373d; }}
        a {{ color: #4fc1ff; text-decoration: none; padding: 2px 4px; display: inline-block; }}
        a:hover {{ background: #2a2d2e; color: #fff; }}
        h3 {{ color: #fff; border-bottom: 1px solid #444; padding-bottom: 10px; margin: 0 0 10px 0; }}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&#39;sidebar&#39;&gt;
    &lt;h3&gt;&#128269; {WebUtility.HtmlEncode(title)}&lt;/h3&gt;&quot;);
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>