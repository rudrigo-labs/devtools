<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using DevTools.Image.Models;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace DevTools.Image.Engine;

internal sealed class ImageSplitter
{
    public byte AlphaThreshold { get; set; } = 10;

    public List&lt;ImageRegion&gt; FindConnectedComponents(Image&lt;Rgba32&gt; image, CancellationToken ct)
    {
        var visited = new bool[image.Width, image.Height];
        var components = new List&lt;ImageRegion&gt;();

        for (int y = 0; y &lt; image.Height; y++)
        {
            ct.ThrowIfCancellationRequested();

            for (int x = 0; x &lt; image.Width; x++)
            {
                if (visited[x, y]) continue;

                var pixel = image[x, y];
                if (pixel.A &lt;= AlphaThreshold)
                {
                    visited[x, y] = true;
                    continue;
                }

                var rect = FloodFill(image, visited, x, y, ct);
                components.Add(rect);
            }
        }

        return components;
    }

    private ImageRegion FloodFill(Image&lt;Rgba32&gt; image, bool[,] visited, int startX, int startY, CancellationToken ct)
    {
        var minX = startX;
        var maxX = startX;
        var minY = startY;
        var maxY = startY;

        var queue = new Queue&lt;PixelPoint&gt;();
        queue.Enqueue(new PixelPoint(startX, startY));
        visited[startX, startY] = true;

        while (queue.Count &gt; 0)
        {
            ct.ThrowIfCancellationRequested();

            var p = queue.Dequeue();

            if (p.X &lt; minX) minX = p.X;
            if (p.X &gt; maxX) maxX = p.X;
            if (p.Y &lt; minY) minY = p.Y;
            if (p.Y &gt; maxY) maxY = p.Y;

            var neighbors = new[]
            {
                new PixelPoint(p.X + 1, p.Y),
                new PixelPoint(p.X - 1, p.Y),
                new PixelPoint(p.X, p.Y + 1),
                new PixelPoint(p.X, p.Y - 1),
                new PixelPoint(p.X + 1, p.Y + 1),
                new PixelPoint(p.X + 1, p.Y - 1),
                new PixelPoint(p.X - 1, p.Y + 1),
                new PixelPoint(p.X - 1, p.Y - 1)
            };

            foreach (var n in neighbors)
            {
                if (n.X &gt;= 0 &amp;&amp; n.X &lt; image.Width &amp;&amp; n.Y &gt;= 0 &amp;&amp; n.Y &lt; image.Height)
                {
                    if (!visited[n.X, n.Y])
                    {
                        var pixel = image[n.X, n.Y];
                        if (pixel.A &gt; AlphaThreshold)
                        {
                            visited[n.X, n.Y] = true;
                            queue.Enqueue(n);
                        }
                        else
                        {
                            visited[n.X, n.Y] = true;
                        }
                    }
                }
            }
        }

        return new ImageRegion(minX, minY, maxX - minX + 1, maxY - minY + 1);
    }

    private readonly record struct PixelPoint(int X, int Y);
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>