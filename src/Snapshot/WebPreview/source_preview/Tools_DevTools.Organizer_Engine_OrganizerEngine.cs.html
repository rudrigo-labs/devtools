<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using DevTools.Core.Abstractions;
using DevTools.Core.Models;
using DevTools.Core.Results;
using DevTools.Organizer.Models;
using DevTools.Core.Providers;
using DevTools.Organizer.Validation;

namespace DevTools.Organizer.Engine;

public sealed class OrganizerEngine : IDevToolEngine&lt;OrganizerRequest, OrganizerResponse&gt;
{
    private readonly IFileSystem _fs;
    private readonly TextExtractor _extractor = new();

    public OrganizerEngine(IFileSystem? fileSystem = null)
    {
        _fs = fileSystem ?? new SystemFileSystem();
    }

    public Task&lt;RunResult&lt;OrganizerResponse&gt;&gt; ExecuteAsync(
        OrganizerRequest request,
        IProgressReporter? progress = null,
        CancellationToken ct = default)
    {
        var errors = OrganizerRequestValidator.Validate(request, _fs);
        if (errors.Count &gt; 0)
            return Task.FromResult(RunResult&lt;OrganizerResponse&gt;.Fail(errors));

        var inbox = Path.GetFullPath(request.InboxPath);
        var output = Path.GetFullPath(request.OutputPath);
        _fs.CreateDirectory(output);

        var duplicatesDir = Path.Combine(output, &quot;Duplicates&quot;);
        var othersDir = Path.Combine(output, &quot;Outros&quot;);
        _fs.CreateDirectory(duplicatesDir);
        _fs.CreateDirectory(othersDir);

        var config = OrganizerConfigLoader.Load(request.ConfigPath, output);
        var minScore = request.MinScore ?? config.MinScoreDefault;

        var allowed = new HashSet&lt;string&gt;(
            config.AllowedExtensions.Select(e =&gt; e.ToLowerInvariant()),
            StringComparer.OrdinalIgnoreCase);

        var plan = new List&lt;OrganizerPlanItem&gt;();
        var hashMap = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
        var nameMap = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
        var lineMap = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
        var eligibleCount = 0;

        var files = Directory.EnumerateFiles(inbox, &quot;*&quot;, SearchOption.AllDirectories).ToList();
        var idx = 0;

        foreach (var file in files)
        {
            ct.ThrowIfCancellationRequested();
            idx++;

            if (idx % 100 == 0)
                progress?.Report(new ProgressEvent($&quot;Processed {idx}/{files.Count}&quot;, (int)(idx * 100.0 / Math.Max(1, files.Count)), &quot;scan&quot;));

            var ext = Path.GetExtension(file).ToLowerInvariant();
            if (!allowed.Contains(ext))
            {
                plan.Add(new OrganizerPlanItem(file, file, &quot;IGNORED&quot;, &quot;Extens&#227;o n&#227;o permitida&quot;, OrganizerAction.Ignored));
                continue;
            }

            eligibleCount++;

            var fileName = Path.GetFileName(file);
            var nameKey = BuildNameKey(fileName);

            if (config.DeduplicateByName &amp;&amp; !string.IsNullOrWhiteSpace(nameKey) &amp;&amp; nameMap.ContainsKey(nameKey))
            {
                plan.Add(new OrganizerPlanItem(
                    file,
                    UniqueTarget(duplicatesDir, fileName),
                    &quot;DUPLICATE&quot;,
                    &quot;Nome igual (dedup por nome)&quot;,
                    OrganizerAction.Duplicate));
                continue;
            }

            string? hash = null;
            if (config.DeduplicateByHash)
            {
                try
                {
                    hash = ComputeHash(file);
                }
                catch (Exception ex)
                {
                    plan.Add(new OrganizerPlanItem(file, file, &quot;ERROR&quot;, $&quot;Erro hash: {ex.Message}&quot;, OrganizerAction.Error));
                    continue;
                }

                if (hashMap.ContainsKey(hash))
                {
                    plan.Add(new OrganizerPlanItem(
                        file,
                        UniqueTarget(duplicatesDir, fileName),
                        &quot;DUPLICATE&quot;,
                        &quot;Hash igual (arquivo id&#234;ntico)&quot;,
                        OrganizerAction.Duplicate));
                    continue;
                }
            }

            var text = _extractor.Extract(file);
            var lineKey = BuildFirstLinesKey(text, config.DeduplicateFirstLines);
            if (!string.IsNullOrWhiteSpace(lineKey) &amp;&amp; lineMap.ContainsKey(lineKey))
            {
                plan.Add(new OrganizerPlanItem(
                    file,
                    UniqueTarget(duplicatesDir, fileName),
                    &quot;DUPLICATE&quot;,
                    &quot;Primeiras linhas iguais (dedup por cabecalho)&quot;,
                    OrganizerAction.Duplicate));
                continue;
            }

            if (config.DeduplicateByName &amp;&amp; !string.IsNullOrWhiteSpace(nameKey))
                nameMap[nameKey] = file;
            if (config.DeduplicateByHash &amp;&amp; !string.IsNullOrWhiteSpace(hash))
                hashMap[hash] = file;
            if (!string.IsNullOrWhiteSpace(lineKey))
                lineMap[lineKey] = file;

            var (category, score, reason) = Classify(file, text, config, minScore);

            if (category is null || score &lt; minScore)
            {
                plan.Add(new OrganizerPlanItem(
                    file,
                    UniqueTarget(othersDir, Path.GetFileName(file)),
                    &quot;Outros&quot;,
                    $&quot;Score baixo ({score}). {reason}&quot;,
                    OrganizerAction.WouldMove));
                continue;
            }

            var catDir = Path.Combine(output, category.Folder);
            _fs.CreateDirectory(catDir);

            plan.Add(new OrganizerPlanItem(
                file,
                UniqueTarget(catDir, Path.GetFileName(file)),
                category.Name,
                reason,
                OrganizerAction.WouldMove));
        }

        if (request.Apply)
            Apply(plan);

        var stats = new OrganizerStats(
            plan.Count,
            eligibleCount,
            plan.Count(p =&gt; p.Action == OrganizerAction.WouldMove || p.Action == OrganizerAction.Moved),
            plan.Count(p =&gt; p.Action == OrganizerAction.Duplicate),
            plan.Count(p =&gt; p.Action == OrganizerAction.Ignored),
            plan.Count(p =&gt; p.Action == OrganizerAction.Error));

        var response = new OrganizerResponse(inbox, output, stats, plan);
        return Task.FromResult(RunResult&lt;OrganizerResponse&gt;.Success(response));
    }

    private static (OrganizerCategory? cat, int score, string reason) Classify(
        string filePath,
        string extracted,
        OrganizerConfig config,
        int defaultMinScore)
    {
        var fileName = Path.GetFileName(filePath);
        var normalizedText = TextNormalizer.Normalize(extracted);
        var normalizedName = TextNormalizer.Normalize(fileName);

        OrganizerCategory? best = null;
        var bestScore = int.MinValue;
        var bestReason = &quot;Sem match&quot;;

        foreach (var cat in config.Categories)
        {
            var score = 0;
            var hits = new List&lt;string&gt;();
            var negHits = new List&lt;string&gt;();

            ScoreKeywords(normalizedText, cat.Keywords, cat.KeywordWeight, hits, ref score);
            ScoreKeywords(normalizedName, cat.Keywords, (int)Math.Round(cat.KeywordWeight * config.FileNameWeight), hits, ref score);

            ScoreKeywords(normalizedText, cat.NegativeKeywords, -cat.NegativeWeight, negHits, ref score);
            ScoreKeywords(normalizedName, cat.NegativeKeywords, -(int)Math.Round(cat.NegativeWeight * config.FileNameWeight), negHits, ref score);

            var threshold = cat.MinScore ?? defaultMinScore;
            if (score &gt;= threshold &amp;&amp; score &gt; bestScore)
            {
                bestScore = score;
                best = cat;
                bestReason = BuildReason(score, hits, negHits);
            }
        }

        if (best is null)
            return (null, bestScore == int.MinValue ? 0 : bestScore, bestReason);

        return (best, bestScore, bestReason);
    }

    private static void ScoreKeywords(
        string hay,
        string[] keywords,
        int weight,
        List&lt;string&gt; hits,
        ref int score)
    {
        if (keywords.Length == 0 || string.IsNullOrWhiteSpace(hay))
            return;

        foreach (var kw in keywords)
        {
            if (string.IsNullOrWhiteSpace(kw)) continue;

            if (kw.StartsWith(&quot;re:&quot;, StringComparison.OrdinalIgnoreCase))
            {
                var pattern = kw[3..];
                if (Regex.IsMatch(hay, pattern, RegexOptions.IgnoreCase))
                {
                    score += weight;
                    hits.Add(kw);
                }
                continue;
            }

            if (hay.Contains(TextNormalizer.Normalize(kw)))
            {
                score += weight;
                hits.Add(kw);
            }
        }
    }

    private static string BuildReason(int score, List&lt;string&gt; hits, List&lt;string&gt; negHits)
    {
        var h = hits.Count == 0 ? &quot;Sem match&quot; : $&quot;Hits: {string.Join(&quot;, &quot;, hits.Take(8))}&quot;;
        var n = negHits.Count == 0 ? &quot;&quot; : $&quot; | Neg: {string.Join(&quot;, &quot;, negHits.Take(6))}&quot;;
        return $&quot;{h}{n} | Score={score}&quot;;
    }

    private static void Apply(List&lt;OrganizerPlanItem&gt; plan)
    {
        for (int i = 0; i &lt; plan.Count; i++)
        {
            var item = plan[i];
            if (item.Action is OrganizerAction.Ignored or OrganizerAction.Error)
                continue;

            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(item.Target)!);
                if (!File.Exists(item.Source))
                {
                    plan[i] = item with { Action = OrganizerAction.Error, Reason = item.Reason + &quot; | Source missing&quot; };
                    continue;
                }

                File.Move(item.Source, item.Target);
                if (item.Action == OrganizerAction.Duplicate)
                    plan[i] = item;
                else
                    plan[i] = item with { Action = OrganizerAction.Moved };
            }
            catch (Exception ex)
            {
                plan[i] = item with { Action = OrganizerAction.Error, Reason = item.Reason + &quot; | Move failed: &quot; + ex.Message };
            }
        }
    }

    private static string UniqueTarget(string dir, string fileName)
    {
        var baseName = Path.GetFileNameWithoutExtension(fileName);
        var ext = Path.GetExtension(fileName);
        var candidate = Path.Combine(dir, fileName);
        if (!File.Exists(candidate)) return candidate;

        for (int i = 1; i &lt;= 9999; i++)
        {
            var alt = Path.Combine(dir, $&quot;{baseName} ({i}){ext}&quot;);
            if (!File.Exists(alt)) return alt;
        }

        return Path.Combine(dir, $&quot;{baseName} ({Guid.NewGuid():N}){ext}&quot;);
    }

    private static string BuildNameKey(string fileName)
    {
        var baseName = Path.GetFileNameWithoutExtension(fileName);
        var normalized = TextNormalizer.Normalize(baseName);
        if (!string.IsNullOrWhiteSpace(normalized))
            return normalized;

        return TextNormalizer.Normalize(fileName);
    }

    private static string BuildFirstLinesKey(string extracted, int lineCount)
    {
        if (lineCount &lt;= 0 || string.IsNullOrWhiteSpace(extracted))
            return string.Empty;

        var sb = new StringBuilder();
        using var reader = new StringReader(extracted);
        string? line;
        var count = 0;

        while (count &lt; lineCount &amp;&amp; (line = reader.ReadLine()) is not null)
        {
            var trimmed = line.Trim();
            if (string.IsNullOrWhiteSpace(trimmed))
                continue;

            if (sb.Length &gt; 0)
                sb.Append(&#39;\n&#39;);

            sb.Append(TextNormalizer.Normalize(trimmed));
            count++;
        }

        return sb.ToString();
    }

    private static string ComputeHash(string file)
    {
        using var sha = SHA256.Create();
        using var fs = File.OpenRead(file);
        return Convert.ToHexString(sha.ComputeHash(fs));
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>