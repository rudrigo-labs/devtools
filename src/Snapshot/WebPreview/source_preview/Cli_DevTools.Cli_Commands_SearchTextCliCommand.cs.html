<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using DevTools.Cli.Ui;
using DevTools.Cli.Logging;
using DevTools.Cli.App;
using DevTools.SearchText.Engine;
using DevTools.SearchText.Models;

namespace DevTools.Cli.Commands;

public sealed class SearchTextCliCommand : ICliCommand
{
    private readonly CliConsole _ui;
    private readonly CliInput _input;
    private readonly SearchTextEngine _engine;

    public SearchTextCliCommand(CliConsole ui, CliInput input)
    {
        _ui = ui;
        _input = input;
        _engine = new SearchTextEngine();
    }

    public string Key =&gt; &quot;searchtext&quot;;
    public string Name =&gt; &quot;Search Text&quot;;
    public string Description =&gt; &quot;Busca texto ou regex em arquivos com filtros.&quot;;

    public async Task&lt;int&gt; ExecuteAsync(CliLaunchOptions options, CancellationToken ct)
    {
        // 1. Resolve Parameters
        var root = options.GetOption(&quot;root&quot;) ?? options.GetOption(&quot;path&quot;);
        var pattern = options.GetOption(&quot;pattern&quot;) ?? options.GetOption(&quot;text&quot;);
        var regexStr = options.GetOption(&quot;regex&quot;);
        var caseSensitiveStr = options.GetOption(&quot;case-sensitive&quot;) ?? options.GetOption(&quot;case&quot;);
        var wholeWordStr = options.GetOption(&quot;whole-word&quot;) ?? options.GetOption(&quot;word&quot;);
        var includeStr = options.GetOption(&quot;include&quot;);
        var excludeStr = options.GetOption(&quot;exclude&quot;);
        var maxSizeStr = options.GetOption(&quot;max-size&quot;) ?? options.GetOption(&quot;size&quot;);
        var skipBinaryStr = options.GetOption(&quot;skip-binary&quot;) ?? options.GetOption(&quot;binary&quot;);
        var maxPerFileStr = options.GetOption(&quot;max-per-file&quot;);
        var showLinesStr = options.GetOption(&quot;show-lines&quot;) ?? options.GetOption(&quot;lines&quot;);

        bool? regex = regexStr != null ? (regexStr == &quot;true&quot;) : null;
        bool? caseSensitive = caseSensitiveStr != null ? (caseSensitiveStr == &quot;true&quot;) : null;
        bool? wholeWord = wholeWordStr != null ? (wholeWordStr == &quot;true&quot;) : null;
        bool? skipBinary = skipBinaryStr != null ? (skipBinaryStr == &quot;true&quot;) : null;
        bool? showLines = showLinesStr != null ? (showLinesStr == &quot;true&quot;) : null;
        int? maxSize = int.TryParse(maxSizeStr, out var s) ? s : null;
        int? maxPerFile = int.TryParse(maxPerFileStr, out var m) ? m : null;

        // Interactive Fallback
        if (!options.IsNonInteractive)
        {
            if (string.IsNullOrWhiteSpace(root))
            {
                root = _input.ReadRequired(&quot;Pasta raiz&quot;, &quot;ex: C:\\Projetos\\MeuApp&quot;);
                options.Options[&quot;root&quot;] = root;
            }
            
            if (string.IsNullOrWhiteSpace(pattern))
            {
                pattern = _input.ReadRequired(&quot;Texto ou regex&quot;);
                options.Options[&quot;pattern&quot;] = pattern;
            }
            
            if (regex == null)
            {
                regex = _input.ReadYesNo(&quot;Usar regex&quot;, false);
                options.Options[&quot;regex&quot;] = regex.Value.ToString().ToLower();
            }
            
            if (caseSensitive == null)
            {
                caseSensitive = _input.ReadYesNo(&quot;Diferenciar maiusculas&quot;, false);
                options.Options[&quot;case-sensitive&quot;] = caseSensitive.Value.ToString().ToLower();
            }
            
            if (wholeWord == null)
            {
                wholeWord = _input.ReadYesNo(&quot;Palavra inteira&quot;, false);
                options.Options[&quot;whole-word&quot;] = wholeWord.Value.ToString().ToLower();
            }

            if (string.IsNullOrWhiteSpace(includeStr))
            {
                var list = _input.ReadCsv(&quot;Includes (globs)&quot;, &quot;ex: src/**/*.cs, **/*.md&quot;);
                if (list.Count &gt; 0) 
                {
                    includeStr = string.Join(&quot;,&quot;, list);
                    options.Options[&quot;include&quot;] = includeStr;
                }
            }
            
            if (string.IsNullOrWhiteSpace(excludeStr))
            {
                var list = _input.ReadCsv(&quot;Excludes (globs)&quot;, &quot;ex: bin/**, obj/**&quot;);
                if (list.Count &gt; 0) 
                {
                    excludeStr = string.Join(&quot;,&quot;, list);
                    options.Options[&quot;exclude&quot;] = excludeStr;
                }
            }

            if (maxSize == null)
            {
                maxSize = _input.ReadOptionalInt(&quot;Max KB por arquivo&quot;, &quot;enter para ignorar&quot;);
                if (maxSize.HasValue) options.Options[&quot;max-size&quot;] = maxSize.Value.ToString();
            }
            
            if (skipBinary == null)
            {
                skipBinary = _input.ReadYesNo(&quot;Ignorar binarios&quot;, true);
                options.Options[&quot;skip-binary&quot;] = skipBinary.Value.ToString().ToLower();
            }
            
            if (maxPerFile == null)
            {
                maxPerFile = _input.ReadOptionalInt(&quot;Max matches por arquivo&quot;, &quot;0 = sem limite&quot;) ?? 0;
                options.Options[&quot;max-per-file&quot;] = maxPerFile.Value.ToString();
            }
            
            if (showLines == null)
            {
                showLines = _input.ReadYesNo(&quot;Mostrar linhas&quot;, true);
                options.Options[&quot;show-lines&quot;] = showLines.Value.ToString().ToLower();
            }
        }

        // Defaults
        regex ??= false;
        caseSensitive ??= false;
        wholeWord ??= false;
        skipBinary ??= true;
        maxPerFile ??= 0;
        showLines ??= true;

        // Validation
        if (string.IsNullOrWhiteSpace(root))
        {
            _ui.WriteError(&quot;Root path required (--root).&quot;);
            return 1;
        }
        if (string.IsNullOrWhiteSpace(pattern))
        {
            _ui.WriteError(&quot;Pattern required (--pattern).&quot;);
            return 1;
        }

        var includeList = !string.IsNullOrWhiteSpace(includeStr)
            ? includeStr.Split(&#39;,&#39;, StringSplitOptions.RemoveEmptyEntries).Select(s =&gt; s.Trim()).ToList()
            : null;
        
        var excludeList = !string.IsNullOrWhiteSpace(excludeStr)
            ? excludeStr.Split(&#39;,&#39;, StringSplitOptions.RemoveEmptyEntries).Select(s =&gt; s.Trim()).ToList()
            : null;

        var request = new SearchTextRequest(
            root,
            pattern,
            regex.Value,
            caseSensitive.Value,
            wholeWord.Value,
            includeList,
            excludeList,
            maxSize,
            skipBinary.Value,
            maxPerFile.Value,
            showLines.Value);

        using var progress = new CliProgressReporter(_ui.Theme);
        var result = await _engine.ExecuteAsync(request, progress, ct).ConfigureAwait(false);
        progress.Finish();

        if (!result.IsSuccess || result.Value is null)
        {
            WriteErrors(result.Errors);
            return 1;
        }

        var response = result.Value;
        
        if (!options.IsNonInteractive)
        {
            _ui.Section(&quot;Resumo&quot;);
            _ui.WriteKeyValue(&quot;Arquivos&quot;, response.TotalFilesScanned.ToString());
            _ui.WriteKeyValue(&quot;Com match&quot;, response.TotalFilesWithMatches.ToString());
            _ui.WriteKeyValue(&quot;Ocorrencias&quot;, response.TotalOccurrences.ToString());

            if (response.TotalFilesWithMatches &gt; 0)
            {
                var showDetails = _input.ReadYesNo(&quot;Mostrar detalhes&quot;, true);
                if (showDetails)
                {
                    _ui.Section(&quot;Resultados&quot;);
                    foreach (var file in response.Files.OrderBy(f =&gt; f.RelativePath))
                    {
                        _ui.WriteLine($&quot;{file.RelativePath} | {file.Occurrences}&quot;);
                        if (!showLines.Value)
                            continue;

                        foreach (var line in file.Lines)
                        {
                            var cols = string.Join(&quot;,&quot;, line.Columns);
                            _ui.WriteDim($&quot;  {line.LineNumber}:{cols}  {line.LineText}&quot;);
                        }
                        _ui.WriteLine();
                    }
                }
            }
        }
        else
        {
            // In non-interactive mode, output results if matches found
             if (response.TotalFilesWithMatches &gt; 0)
            {
                foreach (var file in response.Files.OrderBy(f =&gt; f.RelativePath))
                {
                    Console.WriteLine($&quot;{file.RelativePath}:{file.Occurrences}&quot;); // Simple format for piping
                    if (showLines.Value)
                    {
                        foreach (var line in file.Lines)
                        {
                            var cols = string.Join(&quot;,&quot;, line.Columns);
                            Console.WriteLine($&quot;  {line.LineNumber}:{cols}  {line.LineText}&quot;);
                        }
                    }
                }
            }
        }

        return 0;
    }

    private void WriteErrors(IReadOnlyList&lt;DevTools.Core.Results.ErrorDetail&gt; errors)
    {
        CliErrorLogger.LogErrors(Key, errors);
        _ui.Section(&quot;Erros&quot;);
        foreach (var error in errors)
        {
            _ui.WriteError($&quot;{error.Code}: {error.Message}&quot;);
            if (!string.IsNullOrWhiteSpace(error.Details))
                _ui.WriteDim(error.Details);
        }
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>