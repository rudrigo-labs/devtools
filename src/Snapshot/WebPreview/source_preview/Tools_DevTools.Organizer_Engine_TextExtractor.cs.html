<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Linq;
using System.Text;
using System.IO.Compression;
using System.Xml.Linq;
using UglyToad.PdfPig;

namespace DevTools.Organizer.Engine;

internal sealed class TextExtractor
{
    public string Extract(string filePath, int maxChars = 30000)
    {
        var ext = Path.GetExtension(filePath).ToLowerInvariant();

        try
        {
            if (ext is &quot;.txt&quot; or &quot;.md&quot; or &quot;.log&quot;)
                return File.ReadAllText(filePath);

            if (ext == &quot;.pdf&quot;)
            {
                var sb = new StringBuilder();
                using var doc = PdfDocument.Open(filePath);
                foreach (var page in doc.GetPages())
                {
                    sb.AppendLine(page.Text);
                    if (sb.Length &gt; maxChars) break;
                }
                return sb.ToString();
            }

            if (ext == &quot;.doc&quot;)
            {
                return TryExtractDoc(filePath, maxChars);
            }

            if (ext == &quot;.docx&quot;)
            {
                using var archive = ZipFile.OpenRead(filePath);
                var entry = archive.GetEntry(&quot;word/document.xml&quot;);
                if (entry is null)
                    return string.Empty;

                using var stream = entry.Open();
                var doc = XDocument.Load(stream);
                var sb = new StringBuilder();

                foreach (var paragraph in doc.Descendants().Where(e =&gt; e.Name.LocalName == &quot;p&quot;))
                {
                    foreach (var text in paragraph.Descendants().Where(e =&gt; e.Name.LocalName == &quot;t&quot;))
                    {
                        sb.Append(text.Value);
                        if (sb.Length &gt; maxChars) break;
                    }
                    sb.AppendLine();
                    if (sb.Length &gt; maxChars) break;
                }

                return sb.ToString();
            }
        }
        catch
        {
            return string.Empty;
        }

        return string.Empty;
    }

    private static string TryExtractDoc(string filePath, int maxChars)
    {
        var hwpfType = Type.GetType(&quot;NPOI.HWPF.UserModel.HWPFDocument, NPOI&quot;);
        if (hwpfType is null)
            return string.Empty;

        using var stream = File.OpenRead(filePath);
        object? doc = null;
        try
        {
            doc = Activator.CreateInstance(hwpfType, stream);
            var prop = hwpfType.GetProperty(&quot;DocumentText&quot;);
            var text = prop?.GetValue(doc) as string ?? string.Empty;
            return text.Length &gt; maxChars ? text[..maxChars] : text;
        }
        catch
        {
            return string.Empty;
        }
        finally
        {
            if (doc is IDisposable disposable)
                disposable.Dispose();
        }
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>