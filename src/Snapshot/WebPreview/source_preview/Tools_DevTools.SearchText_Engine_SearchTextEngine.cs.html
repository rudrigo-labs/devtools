<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Text;
using DevTools.Core.Abstractions;
using DevTools.Core.Models;
using DevTools.Core.Results;
using DevTools.SearchText.Models;
using DevTools.Core.Providers;
using DevTools.SearchText.Validation;
using DevTools.Core.Utilities;

namespace DevTools.SearchText.Engine;

public sealed class SearchTextEngine : IDevToolEngine&lt;SearchTextRequest, SearchTextResponse&gt;
{
    private static readonly UTF8Encoding Utf8Strict = new(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);
    private const int SampleBytes = 4096;

    private readonly IFileSystem _fs;

    public SearchTextEngine(IFileSystem? fileSystem = null)
    {
        _fs = fileSystem ?? new SystemFileSystem();
    }

    public async Task&lt;RunResult&lt;SearchTextResponse&gt;&gt; ExecuteAsync(
        SearchTextRequest request,
        IProgressReporter? progress = null,
        CancellationToken ct = default)
    {
        var errors = SearchTextRequestValidator.Validate(request, _fs);
        if (errors.Count &gt; 0)
            return RunResult&lt;SearchTextResponse&gt;.Fail(errors);

        var include = request.IncludeGlobs?.Where(g =&gt; !string.IsNullOrWhiteSpace(g)).ToList() ?? new List&lt;string&gt;();
        var exclude = request.ExcludeGlobs?.Where(g =&gt; !string.IsNullOrWhiteSpace(g)).ToList() ?? new List&lt;string&gt;();
        if (exclude.Count == 0)
            exclude = SearchTextDefaults.DefaultExcludeGlobs;

        var matcher = new TextMatcher(request.Pattern, request.UseRegex, request.CaseSensitive, request.WholeWord);

        var root = Path.GetFullPath(request.RootPath);
        var results = new List&lt;SearchTextFileMatch&gt;();
        var totalOccurrences = 0;
        var totalScanned = 0;

        progress?.Report(new ProgressEvent(&quot;Searching&quot;, 5, &quot;scan&quot;));

        var idx = 0;
        foreach (var file in EnumerateFiles(root, include, exclude, ct))
        {
            ct.ThrowIfCancellationRequested();
            idx++;
            totalScanned++;

            if (idx % 100 == 0)
                progress?.Report(new ProgressEvent($&quot;Processed {idx} files&quot;, null, &quot;scan&quot;));

            if (request.MaxFileSizeKb.HasValue)
            {
                try
                {
                    var info = new FileInfo(file);
                    if (info.Length &gt; request.MaxFileSizeKb.Value * 1024L)
                        continue;
                }
                catch
                {
                    continue;
                }
            }

            var match = await SearchFileAsync(file, root, matcher, request, ct).ConfigureAwait(false);
            if (match is null) continue;

            results.Add(match);
            totalOccurrences += match.Occurrences;
        }

        var response = new SearchTextResponse(
            root,
            totalScanned,
            results.Count,
            totalOccurrences,
            results);

        progress?.Report(new ProgressEvent(&quot;Done&quot;, 100, &quot;done&quot;));
        return RunResult&lt;SearchTextResponse&gt;.Success(response);
    }

    private async Task&lt;SearchTextFileMatch?&gt; SearchFileAsync(
        string fullPath,
        string root,
        TextMatcher matcher,
        SearchTextRequest request,
        CancellationToken ct)
    {
        using var stream = File.Open(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        var sample = ReadSample(stream, SampleBytes);
        var detection = DetectEncoding(sample);

        if (request.SkipBinaryFiles &amp;&amp; detection.IsBinary)
            return null;

        stream.Position = 0;
        using var reader = new StreamReader(stream, detection.Encoding, detectEncodingFromByteOrderMarks: true);

        var lineNo = 0;
        var occurrences = 0;
        var lineMatches = new List&lt;SearchTextLineMatch&gt;();

        string? line;
        while ((line = await reader.ReadLineAsync(ct).ConfigureAwait(false)) is not null)
        {
            lineNo++;
            var cols = new List&lt;int&gt;();

            foreach (var (idx, len) in matcher.FindMatches(line))
            {
                cols.Add(idx + 1);
                occurrences++;

                if (request.MaxMatchesPerFile &gt; 0 &amp;&amp; occurrences &gt;= request.MaxMatchesPerFile)
                    break;
            }

            if (cols.Count &gt; 0 &amp;&amp; request.ReturnLines)
                lineMatches.Add(new SearchTextLineMatch(lineNo, line, cols));

            if (request.MaxMatchesPerFile &gt; 0 &amp;&amp; occurrences &gt;= request.MaxMatchesPerFile)
                break;
        }

        if (occurrences == 0)
            return null;

        return new SearchTextFileMatch(
            fullPath,
            Path.GetRelativePath(root, fullPath).Replace(&#39;\\&#39;, &#39;/&#39;),
            occurrences,
            lineMatches);
    }

    private static IEnumerable&lt;string&gt; EnumerateFiles(
        string root,
        IReadOnlyList&lt;string&gt; include,
        IReadOnlyList&lt;string&gt; exclude,
        CancellationToken ct)
    {
        var stack = new Stack&lt;string&gt;();
        stack.Push(root);

        while (stack.Count &gt; 0)
        {
            ct.ThrowIfCancellationRequested();

            var dir = stack.Pop();
            IEnumerable&lt;string&gt; subDirs = Array.Empty&lt;string&gt;();
            IEnumerable&lt;string&gt; files = Array.Empty&lt;string&gt;();

            try
            {
                subDirs = Directory.EnumerateDirectories(dir);
                files = Directory.EnumerateFiles(dir);
            }
            catch
            {
                continue;
            }

            foreach (var sd in subDirs)
            {
                var rel = Path.GetRelativePath(root, sd).Replace(&#39;\\&#39;, &#39;/&#39;) + &quot;/&quot;;
                if (IsExcluded(rel, include, exclude))
                    continue;
                stack.Push(sd);
            }

            foreach (var file in files)
            {
                var rel = Path.GetRelativePath(root, file).Replace(&#39;\\&#39;, &#39;/&#39;);
                if (IsExcluded(rel, include, exclude))
                    continue;
                yield return file;
            }
        }
    }

    private static bool IsExcluded(string relativePath, IReadOnlyList&lt;string&gt; include, IReadOnlyList&lt;string&gt; exclude)
    {
        if (exclude.Count &gt; 0 &amp;&amp; exclude.Any(g =&gt; GlobMatcher.IsMatch(relativePath, g)))
            return true;

        if (include.Count == 0)
            return false;

        return !include.Any(g =&gt; GlobMatcher.IsMatch(relativePath, g));
    }

    private static EncodingDetection DetectEncoding(byte[] bytes)
    {
        if (bytes.Length == 0)
            return new EncodingDetection(new UTF8Encoding(false), false);

        var bom = GetBomEncoding(bytes, out _);
        if (bom is not null)
            return new EncodingDetection(bom, false);

        if (TryDetectUtf32(bytes, out var utf32))
            return new EncodingDetection(utf32, false);

        if (TryDetectUtf16(bytes, out var utf16))
            return new EncodingDetection(utf16, false);

        if (TryDecodeUtf8(bytes))
            return new EncodingDetection(new UTF8Encoding(false), false);

        if (LooksBinary(bytes))
            return new EncodingDetection(Encoding.UTF8, true);

        return new EncodingDetection(Encoding.Latin1, false);
    }

    private static byte[] ReadSample(Stream stream, int maxBytes)
    {
        var buffer = new byte[Math.Max(1, maxBytes)];
        var read = stream.Read(buffer, 0, buffer.Length);
        if (read == buffer.Length)
            return buffer;

        var trimmed = new byte[read];
        Array.Copy(buffer, trimmed, read);
        return trimmed;
    }

    private static Encoding? GetBomEncoding(byte[] bytes, out int bomLength)
    {
        bomLength = 0;
        if (bytes.Length &gt;= 3 &amp;&amp; bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF)
        {
            bomLength = 3;
            return new UTF8Encoding(true);
        }

        if (bytes.Length &gt;= 4 &amp;&amp; bytes[0] == 0xFF &amp;&amp; bytes[1] == 0xFE &amp;&amp; bytes[2] == 0x00 &amp;&amp; bytes[3] == 0x00)
        {
            bomLength = 4;
            return new UTF32Encoding(false, true);
        }

        if (bytes.Length &gt;= 4 &amp;&amp; bytes[0] == 0x00 &amp;&amp; bytes[1] == 0x00 &amp;&amp; bytes[2] == 0xFE &amp;&amp; bytes[3] == 0xFF)
        {
            bomLength = 4;
            return new UTF32Encoding(true, true);
        }

        if (bytes.Length &gt;= 2 &amp;&amp; bytes[0] == 0xFF &amp;&amp; bytes[1] == 0xFE)
        {
            bomLength = 2;
            return new UnicodeEncoding(false, true);
        }

        if (bytes.Length &gt;= 2 &amp;&amp; bytes[0] == 0xFE &amp;&amp; bytes[1] == 0xFF)
        {
            bomLength = 2;
            return new UnicodeEncoding(true, true);
        }

        return null;
    }

    private static bool TryDecodeUtf8(byte[] bytes)
    {
        try
        {
            _ = Utf8Strict.GetString(bytes);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool TryDetectUtf16(byte[] bytes, out Encoding encoding)
    {
        encoding = new UnicodeEncoding(false, false);

        if (!bytes.Any(b =&gt; b == 0))
            return false;

        var sample = bytes.Length &gt; SampleBytes ? bytes.AsSpan(0, SampleBytes) : bytes.AsSpan();
        int evenZero = 0, oddZero = 0;
        int evenCount = 0, oddCount = 0;

        for (int i = 0; i &lt; sample.Length; i++)
        {
            if (i % 2 == 0)
            {
                evenCount++;
                if (sample[i] == 0) evenZero++;
            }
            else
            {
                oddCount++;
                if (sample[i] == 0) oddZero++;
            }
        }

        if (evenCount == 0 || oddCount == 0)
            return false;

        var evenRatio = evenZero / (double)evenCount;
        var oddRatio = oddZero / (double)oddCount;

        if (oddRatio &gt; 0.6 &amp;&amp; evenRatio &lt; 0.2)
        {
            encoding = new UnicodeEncoding(false, false);
            return true;
        }

        if (evenRatio &gt; 0.6 &amp;&amp; oddRatio &lt; 0.2)
        {
            encoding = new UnicodeEncoding(true, false);
            return true;
        }

        return false;
    }

    private static bool TryDetectUtf32(byte[] bytes, out Encoding encoding)
    {
        encoding = new UTF32Encoding(false, false);

        if (bytes.Length &lt; 4 || !bytes.Any(b =&gt; b == 0))
            return false;

        var sample = bytes.Length &gt; SampleBytes ? bytes.AsSpan(0, SampleBytes) : bytes.AsSpan();
        int mod0 = 0, mod1 = 0, mod2 = 0, mod3 = 0;
        int mod0Count = 0, mod1Count = 0, mod2Count = 0, mod3Count = 0;

        for (int i = 0; i &lt; sample.Length; i++)
        {
            var mod = i % 4;
            switch (mod)
            {
                case 0:
                    mod0Count++;
                    if (sample[i] == 0) mod0++;
                    break;
                case 1:
                    mod1Count++;
                    if (sample[i] == 0) mod1++;
                    break;
                case 2:
                    mod2Count++;
                    if (sample[i] == 0) mod2++;
                    break;
                case 3:
                    mod3Count++;
                    if (sample[i] == 0) mod3++;
                    break;
            }
        }

        if (mod0Count == 0 || mod1Count == 0 || mod2Count == 0 || mod3Count == 0)
            return false;

        var non0ZeroRatio = (mod1 + mod2 + mod3) / (double)(mod1Count + mod2Count + mod3Count);
        var mod0Ratio = mod0 / (double)mod0Count;

        if (non0ZeroRatio &gt; 0.7 &amp;&amp; mod0Ratio &lt; 0.2)
        {
            encoding = new UTF32Encoding(false, false);
            return true;
        }

        var mod3Ratio = mod3 / (double)mod3Count;
        var non3ZeroRatio = (mod0 + mod1 + mod2) / (double)(mod0Count + mod1Count + mod2Count);

        if (non3ZeroRatio &gt; 0.7 &amp;&amp; mod3Ratio &lt; 0.2)
        {
            encoding = new UTF32Encoding(true, false);
            return true;
        }

        return false;
    }

    private static bool LooksBinary(byte[] bytes)
    {
        var sample = bytes.Length &gt; SampleBytes ? bytes.AsSpan(0, SampleBytes) : bytes.AsSpan();
        if (sample.Length == 0) return false;

        var controlCount = 0;
        foreach (var b in sample)
        {
            if (b == 0) return true;

            if (b &lt; 9 || (b &gt; 13 &amp;&amp; b &lt; 32))
                controlCount++;
        }

        var ratio = controlCount / (double)sample.Length;
        return ratio &gt; 0.3;
    }

    private sealed record EncodingDetection(Encoding Encoding, bool IsBinary);
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>