<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using DevTools.Core.Abstractions;
using DevTools.Core.Models;
using DevTools.SSHTunnel.Abstractions;

namespace DevTools.SSHTunnel.Engine;

public sealed class SshTunnelProcess : IDisposable
{
    private readonly IProcessRunner _runner;
    private CancellationTokenSource? _cts;
    private Task&lt;ProcessResult&gt;? _runTask;
    private ProcessResult? _lastResult;
    private Exception? _lastException;
    private int? _processId;

    public SshTunnelProcess(IProcessRunner runner)
    {
        _runner = runner ?? throw new ArgumentNullException(nameof(runner));
    }

    public bool IsRunning =&gt; _runTask is { IsCompleted: false };

    public int? ProcessId =&gt; _processId;

    public ProcessResult? LastResult =&gt; _lastResult;

    public Exception? LastException =&gt; _lastException;

    public async Task StartAsync(string args, TimeSpan startupTimeout, CancellationToken ct = default)
    {
        if (IsRunning)
            return;

        _cts?.Dispose();
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);

        _runTask = _runner.RunAsync(&quot;ssh&quot;, args, null, null, _cts.Token);

        if (_runner is IProcessRunnerWithPid pidRunner)
            _processId = pidRunner.LastProcessId;

        _ = _runTask.ContinueWith(t =&gt;
        {
            if (t.Status == TaskStatus.RanToCompletion)
                _lastResult = t.Result;
            else if (t.Exception is not null)
                _lastException = t.Exception.GetBaseException();
        }, TaskScheduler.Default);

        var completed = await Task.WhenAny(_runTask, Task.Delay(startupTimeout, ct)).ConfigureAwait(false);

        if (completed == _runTask)
        {
            try
            {
                var result = await _runTask.ConfigureAwait(false);
                _lastResult = result;
                throw new SshTunnelConnectionException(
                    &quot;sshtunnel.connection.failed&quot;,
                    &quot;SSH encerrou antes de estabelecer o t&#250;nel.&quot;,
                    BuildDetails(result));
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (SshTunnelConnectionException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _lastException = ex;
                throw new SshTunnelConnectionException(
                    &quot;sshtunnel.connection.failed&quot;,
                    &quot;Falha ao iniciar o SSH.&quot;,
                    ex.Message,
                    ex);
            }
        }
    }

    public async Task StopAsync(TimeSpan timeout, CancellationToken ct = default)
    {
        if (_cts is null || _runTask is null)
            return;

        try
        {
            _cts.Cancel();
        }
        catch
        {
            // ignore
        }

        try
        {
            await Task.WhenAny(_runTask, Task.Delay(timeout, ct)).ConfigureAwait(false);

            if (!_runTask.IsCompleted)
                TryKillByPid();
        }
        catch (OperationCanceledException)
        {
            // ignore
        }
        catch
        {
            // ignore
        }
        finally
        {
            _cts.Dispose();
            _cts = null;
        }
    }

    private void TryKillByPid()
    {
        if (!_processId.HasValue)
            return;

        try
        {
            using var process = System.Diagnostics.Process.GetProcessById(_processId.Value);
            if (!process.HasExited)
            {
                process.Kill(entireProcessTree: true);
                process.WaitForExit(1500);
            }
        }
        catch
        {
            // ignore
        }
    }

    private static string BuildDetails(ProcessResult result)
    {
        var details = new List&lt;string&gt;();
        if (!string.IsNullOrWhiteSpace(result.StdErr))
            details.Add($&quot;STDERR:\n{result.StdErr.Trim()}&quot;);
        if (!string.IsNullOrWhiteSpace(result.StdOut))
            details.Add($&quot;STDOUT:\n{result.StdOut.Trim()}&quot;);
        return details.Count == 0
            ? $&quot;ExitCode: {result.ExitCode}&quot;
            : string.Join(&quot;\n\n&quot;, details);
    }

    public void Dispose()
    {
        try
        {
            StopAsync(TimeSpan.FromSeconds(2)).GetAwaiter().GetResult();
        }
        catch
        {
            // ignore
        }
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>