<html><head><meta charset='UTF-8'>
<link rel='stylesheet' href='../prism-tomorrow.min.css'>
<style>
body { background: #1d1d1d; margin: 0; padding: 10px; font-size: 14px; }
pre { border-radius: 6px; }
</style>
</head><body>
<pre><code class='language-csharp'>using System.Text;
using DevTools.Core.Abstractions;
using DevTools.Core.Providers;
using DevTools.Core.Results;
using DevTools.Notes.Models;

namespace DevTools.Notes.Providers;

public sealed class NotesSimpleStore
{
    private readonly IFileSystem _fs;
    private readonly NotesIndexStore _indexStore;

    public NotesSimpleStore(IFileSystem? fileSystem = null)
    {
        _fs = fileSystem ?? new SystemFileSystem();
        _indexStore = new NotesIndexStore(_fs);
    }

    public async Task&lt;RunResult&lt;NoteCreateResult&gt;&gt; CreateAsync(
        string? rootPath,
        string title,
        string content,
        DateTime? localDate,
        bool useMarkdown,
        bool createDateFolder,
        CancellationToken ct = default)
    {
        var root = NotesPaths.ResolveRoot(rootPath);
        var itemsRoot = NotesPaths.ItemsDir(root);
        _fs.CreateDirectory(itemsRoot);

        var nowUtc = DateTime.UtcNow;
        var date = (localDate ?? DateTime.Now).Date;
        var slug = NotesSlug.ToSlug(title);
        var ext = useMarkdown ? &quot;.md&quot; : &quot;.txt&quot;;

        var relativeDir = createDateFolder ? Path.Combine(date.ToString(&quot;yyyy-MM-dd&quot;)) : string.Empty;
        var dir = string.IsNullOrWhiteSpace(relativeDir) ? itemsRoot : Path.Combine(itemsRoot, relativeDir);
        _fs.CreateDirectory(dir);

        var baseFile = $&quot;{date:yyyy-MM-dd} - {slug}{ext}&quot;;
        var fileName = EnsureUniqueFileName(dir, baseFile);
        var path = Path.Combine(dir, fileName);

        var normalized = NormalizeNoteContent(title, content, useMarkdown);
        var sha = NotesHash.Sha256Hex(normalized);

        try
        {
            await _fs.WriteAllTextAsync(path, normalized, ct).ConfigureAwait(false);

            var loadIndex = await _indexStore.LoadAsync(root, ct).ConfigureAwait(false);
            if (!loadIndex.IsSuccess || loadIndex.Value is null)
                return RunResult&lt;NoteCreateResult&gt;.Fail(loadIndex.Errors);

            var index = loadIndex.Value;
            var id = Guid.NewGuid().ToString(&quot;N&quot;);
            var relPath = Path.GetRelativePath(itemsRoot, path).Replace(&#39;\\&#39;, &#39;/&#39;);

            index.Items.Add(new NotesIndexEntry
            {
                Id = id,
                Title = title,
                FileName = relPath,
                CreatedUtc = nowUtc,
                UpdatedUtc = nowUtc,
                Sha256 = sha,
                Tags = null
            });

            var saveIndex = await _indexStore.SaveAsync(root, index, ct).ConfigureAwait(false);
            if (!saveIndex.IsSuccess)
                return RunResult&lt;NoteCreateResult&gt;.Fail(saveIndex.Errors);

            return RunResult&lt;NoteCreateResult&gt;.Success(new NoteCreateResult(
                id,
                title,
                relPath,
                path,
                sha,
                nowUtc,
                nowUtc));
        }
        catch (Exception ex)
        {
            return RunResult&lt;NoteCreateResult&gt;.Fail(new ErrorDetail(
                &quot;notes.simple.create.failed&quot;,
                &quot;Failed to create note.&quot;,
                Cause: path,
                Exception: ex));
        }
    }

    public async Task&lt;RunResult&lt;NoteListResult&gt;&gt; ListAsync(string? rootPath, CancellationToken ct = default)
    {
        var root = NotesPaths.ResolveRoot(rootPath);
        var load = await _indexStore.LoadAsync(root, ct).ConfigureAwait(false);
        if (!load.IsSuccess || load.Value is null)
            return RunResult&lt;NoteListResult&gt;.Fail(load.Errors);

        var items = load.Value.Items
            .OrderByDescending(x =&gt; x.UpdatedUtc)
            .Select(x =&gt; new NoteListItem(
                x.Id,
                x.Title,
                x.FileName,
                x.CreatedUtc,
                x.UpdatedUtc,
                x.Tags))
            .ToList();

        return RunResult&lt;NoteListResult&gt;.Success(new NoteListResult(items));
    }

    private string EnsureUniqueFileName(string dir, string fileName)
    {
        var candidate = fileName;
        var name = Path.GetFileNameWithoutExtension(fileName);
        var ext = Path.GetExtension(fileName);

        var i = 1;
        while (_fs.FileExists(Path.Combine(dir, candidate)))
        {
            i++;
            candidate = $&quot;{name} ({i}){ext}&quot;;
        }

        return candidate;
    }

    private static string NormalizeNoteContent(string title, string content, bool useMarkdown)
    {
        var sb = new StringBuilder();
        if (useMarkdown)
        {
            sb.Append(&quot;# &quot;);
            sb.AppendLine(title.Trim());
            sb.AppendLine();
        }
        else
        {
            sb.AppendLine(title.Trim());
            sb.AppendLine(new string(&#39;-&#39;, Math.Max(3, title.Trim().Length)));
        }

        sb.Append(content ?? string.Empty);
        if (!sb.ToString().EndsWith(&quot;\n&quot;, StringComparison.Ordinal))
            sb.AppendLine();
        return sb.ToString();
    }
}
</code></pre>
<script src='../prism.min.js'></script>
<script src='../prism-csharp.min.js'></script>
<script src='../prism-json.min.js'></script>
<script src='../prism-markdown.min.js'></script>
<script src='../prism-markup.min.js'></script>
<script src='../prism-powershell.min.js'></script>
<script src='../prism-yaml.min.js'></script>

</body></html>